diff --git a/src/Makefile.am b/src/Makefile.am
index 766fd95b9..100530c1f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -4,7 +4,7 @@ BUILT_SOURCES = hamlibdatetime.h
 
 DISTCLEANFILES = hamlibdatetime.h
 
-RIGSRC = hamlibdatetime.h rig.c serial.c serial.h misc.c misc.h register.c register.h event.c \
+RIGSRC = hamlibdatetime.h rig.c serial.c serial.h android_serial_bridge.c android_serial_bridge.h misc.c misc.h register.c register.h event.c \
 	event.h cal.c cal.h conf.c tones.c tones.h rotator.c locator.c rot_reg.c \
 	rot_conf.c rot_conf.h rot_settings.c rot_ext.c iofunc.c iofunc.h ext.c \
 	mem.c settings.c parallel.c parallel.h usb_port.c usb_port.h debug.c \
diff --git a/src/android_serial_bridge.c b/src/android_serial_bridge.c
new file mode 100644
index 000000000..dfced28c6
--- /dev/null
+++ b/src/android_serial_bridge.c
@@ -0,0 +1,347 @@
+/*
+ * Android USB serial bridge hooks for Hamlib.
+ */
+
+#ifdef __ANDROID__
+
+#include "android_serial_bridge.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/socket.h>
+
+/* JNI bridge functions implemented by the Android host library. */
+extern int js8_android_usb_serial_is_ready(void);
+extern int js8_android_usb_serial_open(int device_id,
+                                       int port_index,
+                                       int baud_rate,
+                                       int data_bits,
+                                       int stop_bits,
+                                       int parity);
+extern int js8_android_usb_serial_read(unsigned char *buffer,
+                                       unsigned long length,
+                                       int timeout_ms);
+extern int js8_android_usb_serial_write(const unsigned char *buffer,
+                                        unsigned long length,
+                                        int timeout_ms);
+extern int js8_android_usb_serial_set_rts(int state);
+extern int js8_android_usb_serial_set_dtr(int state);
+extern int js8_android_usb_serial_flush(void);
+extern int js8_android_usb_serial_close(void);
+
+typedef struct android_serial_context {
+    int fd_peer;
+    int running;
+    int timeout_ms;
+    pthread_t rx_thread;
+    pthread_t tx_thread;
+    int rx_started;
+    int tx_started;
+} android_serial_context_t;
+
+__attribute__((weak)) int initrots5_androidsensor(void)
+{
+    return RIG_OK;
+}
+
+static int parse_path(const char *pathname, int *device_id, int *port_index)
+{
+    const char *prefix = "android-usb:";
+    const size_t prefix_len = 12;
+    const char *cursor;
+    char *end = NULL;
+    long dev = 0;
+    long port = 0;
+
+    if (!pathname || strncmp(pathname, prefix, prefix_len) != 0) {
+        return -1;
+    }
+
+    cursor = pathname + prefix_len;
+    if (*cursor == '\0') {
+        return -1;
+    }
+
+    dev = strtol(cursor, &end, 0);
+    if (end == cursor) {
+        return -1;
+    }
+
+    if (end && (*end == ':' || *end == ',')) {
+        port = strtol(end + 1, &end, 0);
+    }
+
+    if (dev < 0 || port < 0) {
+        return -1;
+    }
+
+    *device_id = (int)dev;
+    *port_index = (int)port;
+    return 0;
+}
+
+static void drain_socket(int fd)
+{
+    char buffer[256];
+    ssize_t n;
+
+    for (;;) {
+        n = recv(fd, buffer, sizeof(buffer), MSG_DONTWAIT);
+        if (n <= 0) {
+            if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
+                return;
+            }
+            return;
+        }
+    }
+}
+
+static void *rx_thread_fn(void *arg)
+{
+    android_serial_context_t *ctx = (android_serial_context_t *)arg;
+    unsigned char buffer[512];
+    int error_streak = 0;
+
+    while (ctx->running) {
+        int read = js8_android_usb_serial_read(buffer, sizeof(buffer), ctx->timeout_ms);
+        if (read > 0) {
+            error_streak = 0;
+            ssize_t written = 0;
+            while (written < read && ctx->running) {
+                ssize_t result = write(ctx->fd_peer, buffer + written, read - written);
+                if (result > 0) {
+                    written += result;
+                } else if (result < 0 && errno == EINTR) {
+                    continue;
+                } else {
+                    break;
+                }
+            }
+        } else if (read == 0) {
+            error_streak = 0;
+        } else {
+            error_streak++;
+            if (error_streak == 1 || (error_streak % 50) == 0) {
+                rig_debug(RIG_DEBUG_WARN, "%s: android USB read failed (%d)\n",
+                          __func__, error_streak);
+            }
+            usleep(100000);
+        }
+    }
+
+    return NULL;
+}
+
+static void *tx_thread_fn(void *arg)
+{
+    android_serial_context_t *ctx = (android_serial_context_t *)arg;
+    unsigned char buffer[512];
+
+    while (ctx->running) {
+        ssize_t bytes_read = read(ctx->fd_peer, buffer, sizeof(buffer));
+        if (bytes_read > 0) {
+            ssize_t remaining = bytes_read;
+            unsigned char *cursor = buffer;
+            while (remaining > 0 && ctx->running) {
+                int written = js8_android_usb_serial_write(cursor, (unsigned long)remaining,
+                                                          ctx->timeout_ms);
+                if (written > 0) {
+                    remaining -= written;
+                    cursor += written;
+                } else {
+                    break;
+                }
+            }
+        } else if (bytes_read == 0) {
+            break;
+        } else if (errno == EINTR) {
+            continue;
+        } else {
+            break;
+        }
+    }
+
+    return NULL;
+}
+
+int android_serial_is_path(const char *pathname)
+{
+    if (!pathname) {
+        return 0;
+    }
+
+    return strncmp(pathname, "android-usb:", 12) == 0;
+}
+
+int android_serial_open(hamlib_port_t *port)
+{
+    android_serial_context_t *ctx = NULL;
+    int fds[2] = {-1, -1};
+    int device_id = -1;
+    int port_index = 0;
+    int baud_rate = 0;
+    int data_bits = 8;
+    int stop_bits = 1;
+    int parity = 0;
+
+    if (!port) {
+        return -RIG_EINVAL;
+    }
+
+    if (!js8_android_usb_serial_is_ready()) {
+        return -RIG_ENIMPL;
+    }
+
+    if (parse_path(port->pathname, &device_id, &port_index) != 0) {
+        rig_debug(RIG_DEBUG_ERR, "%s: invalid android-usb path %s\n", __func__, port->pathname);
+        return -RIG_EINVAL;
+    }
+
+    baud_rate = port->parm.serial.rate;
+    data_bits = port->parm.serial.data_bits;
+    stop_bits = port->parm.serial.stop_bits == 2 ? 2 : 1;
+    parity = port->parm.serial.parity;
+    if (data_bits != 7 && data_bits != 8) {
+        data_bits = 8;
+    }
+
+    if (js8_android_usb_serial_open(device_id, port_index, baud_rate, data_bits, stop_bits, parity) != 0) {
+        rig_debug(RIG_DEBUG_ERR, "%s: android USB open failed\n", __func__);
+        return -RIG_EIO;
+    }
+
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) != 0) {
+        js8_android_usb_serial_close();
+        return -RIG_EIO;
+    }
+
+    (void)fcntl(fds[0], F_SETFD, FD_CLOEXEC);
+    (void)fcntl(fds[1], F_SETFD, FD_CLOEXEC);
+
+    ctx = (android_serial_context_t *)calloc(1, sizeof(android_serial_context_t));
+    if (!ctx) {
+        close(fds[0]);
+        close(fds[1]);
+        js8_android_usb_serial_close();
+        return -RIG_ENOMEM;
+    }
+
+    ctx->fd_peer = fds[1];
+    ctx->running = 1;
+    ctx->timeout_ms = port->timeout > 0 ? port->timeout : 1000;
+
+    port->fd = fds[0];
+    port->handle = ctx;
+
+    if (pthread_create(&ctx->rx_thread, NULL, rx_thread_fn, ctx) != 0) {
+        ctx->running = 0;
+        close(fds[0]);
+        close(fds[1]);
+        free(ctx);
+        port->fd = -1;
+        port->handle = NULL;
+        js8_android_usb_serial_close();
+        return -RIG_EIO;
+    }
+    ctx->rx_started = 1;
+
+    if (pthread_create(&ctx->tx_thread, NULL, tx_thread_fn, ctx) != 0) {
+        ctx->running = 0;
+        shutdown(fds[1], SHUT_RDWR);
+        if (ctx->rx_started) {
+            pthread_join(ctx->rx_thread, NULL);
+        }
+        close(fds[0]);
+        close(fds[1]);
+        free(ctx);
+        port->fd = -1;
+        port->handle = NULL;
+        js8_android_usb_serial_close();
+        return -RIG_EIO;
+    }
+    ctx->tx_started = 1;
+
+    return RIG_OK;
+}
+
+int android_serial_setup(hamlib_port_t *port)
+{
+    (void)port;
+    return RIG_OK;
+}
+
+int android_serial_close(hamlib_port_t *port)
+{
+    android_serial_context_t *ctx;
+
+    if (!port) {
+        return -RIG_EINVAL;
+    }
+
+    ctx = (android_serial_context_t *)port->handle;
+    if (!ctx) {
+        return RIG_OK;
+    }
+
+    ctx->running = 0;
+    js8_android_usb_serial_close();
+
+    if (ctx->fd_peer >= 0) {
+        shutdown(ctx->fd_peer, SHUT_RDWR);
+    }
+    if (port->fd >= 0) {
+        shutdown(port->fd, SHUT_RDWR);
+    }
+
+    if (ctx->rx_started) {
+        pthread_join(ctx->rx_thread, NULL);
+    }
+    if (ctx->tx_started) {
+        pthread_join(ctx->tx_thread, NULL);
+    }
+
+    if (ctx->fd_peer >= 0) {
+        close(ctx->fd_peer);
+    }
+    if (port->fd >= 0) {
+        close(port->fd);
+    }
+
+    free(ctx);
+    port->handle = NULL;
+    port->fd = -1;
+
+    return RIG_OK;
+}
+
+int android_serial_flush(hamlib_port_t *port)
+{
+    if (!port) {
+        return -RIG_EINVAL;
+    }
+
+    if (port->fd >= 0) {
+        drain_socket(port->fd);
+    }
+
+    (void)js8_android_usb_serial_flush();
+    return RIG_OK;
+}
+
+int android_serial_set_rts(hamlib_port_t *port, int state)
+{
+    (void)port;
+    return js8_android_usb_serial_set_rts(state) == 0 ? RIG_OK : -RIG_EIO;
+}
+
+int android_serial_set_dtr(hamlib_port_t *port, int state)
+{
+    (void)port;
+    return js8_android_usb_serial_set_dtr(state) == 0 ? RIG_OK : -RIG_EIO;
+}
+
+#endif  /* __ANDROID__ */
diff --git a/src/android_serial_bridge.h b/src/android_serial_bridge.h
new file mode 100644
index 000000000..1f847c058
--- /dev/null
+++ b/src/android_serial_bridge.h
@@ -0,0 +1,34 @@
+/*
+ * Android USB serial bridge hooks for Hamlib.
+ *
+ * These functions are intended to be implemented by the host application
+ * (e.g., via JNI). The default implementation returns -RIG_ENIMPL.
+ */
+
+#ifndef ANDROID_SERIAL_BRIDGE_H
+#define ANDROID_SERIAL_BRIDGE_H 1
+
+#ifdef __ANDROID__
+
+#include "hamlib/rig.h"
+#include "hamlib/port.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int android_serial_is_path(const char *pathname);
+int android_serial_open(hamlib_port_t *port);
+int android_serial_setup(hamlib_port_t *port);
+int android_serial_close(hamlib_port_t *port);
+int android_serial_flush(hamlib_port_t *port);
+int android_serial_set_rts(hamlib_port_t *port, int state);
+int android_serial_set_dtr(hamlib_port_t *port, int state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __ANDROID__ */
+
+#endif  /* ANDROID_SERIAL_BRIDGE_H */
diff --git a/src/microham.c b/src/microham.c
index b18c25765..693d19cd4 100644
--- a/src/microham.c
+++ b/src/microham.c
@@ -272,7 +272,31 @@ static struct uhtypes
 //
 #include <termios.h>
 #include <sys/stat.h>
+#ifdef __ANDROID__
+typedef struct {
+    size_t gl_pathc;
+    char **gl_pathv;
+} glob_t;
+
+static int glob(const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t *p)
+{
+    (void)pattern;
+    (void)flags;
+    (void)errfunc;
+    if (p) {
+        p->gl_pathc = 0;
+        p->gl_pathv = NULL;
+    }
+    return 0;
+}
+
+static void globfree(glob_t *p)
+{
+    (void)p;
+}
+#else
 #include <glob.h>
+#endif
 static void finddevices()
 {
     struct stat st;
@@ -372,6 +396,8 @@ static void finddevices()
                 }
             }
         }
+
+        globfree(&gbuf);
     }
 }
 
diff --git a/src/rig.c b/src/rig.c
index 68e148a11..453cd8075 100644
--- a/src/rig.c
+++ b/src/rig.c
@@ -8579,7 +8579,9 @@ static int async_data_handler_stop(RIG *rig)
         {
             // all cleanup is done in this function so we can kill thread
             // Windows was taking 30 seconds to stop without this
+#ifndef __ANDROID__
             pthread_cancel(async_data_handler_priv->thread_id);
+#endif
             int err = pthread_join(async_data_handler_priv->thread_id, NULL);
 
             if (err)
@@ -8634,7 +8636,9 @@ static int morse_data_handler_stop(RIG *rig)
         {
             // all cleanup is done in this function so we can kill thread
             // Windows was taking 30 seconds to stop without this
+#ifndef __ANDROID__
             pthread_cancel(morse_data_handler_priv->thread_id);
+#endif
             int err = pthread_join(morse_data_handler_priv->thread_id, NULL);
 
             if (err)
diff --git a/src/serial.c b/src/serial.c
index 71d3c68c8..70168ef4a 100644
--- a/src/serial.c
+++ b/src/serial.c
@@ -73,6 +73,10 @@
 //! @endcond
 
 #include "serial.h"
+
+#ifdef __ANDROID__
+#include "android_serial_bridge.h"
+#endif
 #include "misc.h"
 
 #ifdef HAVE_SYS_IOCCOM_H
@@ -223,6 +227,13 @@ int HAMLIB_API serial_open(hamlib_port_t *rp)
         return (-RIG_EINVAL);
     }
 
+#ifdef __ANDROID__
+    if (android_serial_is_path(rp->pathname))
+    {
+        return android_serial_open(rp);
+    }
+#endif
+
 #if defined(WIN32)
     int retcode = check_com_port_in_use(rp->pathname);
 
@@ -839,6 +850,13 @@ int HAMLIB_API serial_flush(hamlib_port_t *p)
 
 #endif
 
+#ifdef __ANDROID__
+    if (android_serial_is_path(p->pathname))
+    {
+        return android_serial_flush(p);
+    }
+#endif
+
     if (p->fd == uh_ptt_fd || p->fd == uh_radio_fd || p->flushx)
     {
         /*
@@ -991,6 +1009,13 @@ int ser_close(hamlib_port_t *p)
 
     //rig_debug(RIG_DEBUG_VERBOSE, "%s called\n", __func__);
 
+#ifdef __ANDROID__
+    if (android_serial_is_path(p->pathname))
+    {
+        return android_serial_close(p);
+    }
+#endif
+
     /*
      * For microHam devices, do not close the
      * socket via close but call a service routine
@@ -1107,6 +1132,13 @@ int HAMLIB_API ser_set_rts(hamlib_port_t *p, int state)
         return (RIG_OK);
     }
 
+#ifdef __ANDROID__
+    if (android_serial_is_path(p->pathname))
+    {
+        return android_serial_set_rts(p, state);
+    }
+#endif
+
 #if defined(TIOCMBIS) && defined(TIOCMBIC)
     rc = IOCTL(p->fd, state ? TIOCMBIS : TIOCMBIC, &y);
 #else
@@ -1190,6 +1222,13 @@ int HAMLIB_API ser_set_dtr(hamlib_port_t *p, int state)
         return (RIG_OK);
     }
 
+#ifdef __ANDROID__
+    if (android_serial_is_path(p->pathname))
+    {
+        return android_serial_set_dtr(p, state);
+    }
+#endif
+
 #if defined(TIOCMBIS) && defined(TIOCMBIC)
     rc = IOCTL(p->fd, state ? TIOCMBIS : TIOCMBIC, &y);
 #else
